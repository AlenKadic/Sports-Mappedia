<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>My Mapbox Studio Map with Directions</title>
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.12.0/mapbox-gl.css" rel="stylesheet">
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.12.0/mapbox-gl.js"></script>

  <!-- Mapbox Search JS (provides MapboxGeocoder custom element/class) -->
  <script id="search-js" defer src="https://api.mapbox.com/search-js/v1.3.0/web.js"></script>

  <link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-directions/v4.3.1/mapbox-gl-directions.css">
  <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-directions/v4.3.1/mapbox-gl-directions.js"></script>

  <!-- PapaParse for optional CSV/Sheet ingestion -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    body { margin: 0; padding: 0; }
    #map { position: absolute; top: 0; bottom: 0; width: 100%; }

    #search-box-container {
      position: absolute;
      z-index: 2;
      width: 50%;
      left: 50%;
      margin-left: -25%;
      top: 10px;
    }

    #toggle-directions, #geolocate-button {
      position: absolute;
      z-index: 10;
      padding: 8px 12px;
      background-color: white;
      border: 1px solid #ccc;
      cursor: pointer;
    }

    #toggle-directions { top: 10px; left: 10px; }
    #geolocate-button { top: 10px; left: 185px; }

    .mapboxgl-ctrl-top-left > .mapboxgl-ctrl { margin-top: 60px !important; }

    #stadium-address-filter {
      position: absolute;
      top: 10px;
      right: 150px;
      z-index: 10;
      padding: 10px;
    }

    /* --- AI panel --- */
    #ai-panel {
      position: absolute;
      top: 70px;
      right: 10px;
      z-index: 20;
      width: 340px;
      max-width: calc(100% - 20px);
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 10px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.12);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    #ai-panel header {
      padding: 10px 12px;
      border-bottom: 1px solid #eee;
      display: flex; align-items: center; justify-content: space-between;
    }
    #ai-panel header h3 { margin: 0; font-size: 14px; font-weight: 600; }
    #ai-panel .content { padding: 10px 12px; }
    #ai-panel label { font-size: 12px; color: #444; display: block; margin-top: 8px; }
    #ai-panel input[type="text"], #ai-panel input[type="password"], #ai-panel textarea {
      width: 100%; box-sizing: border-box; border: 1px solid #ddd; border-radius: 8px; padding: 8px; font-size: 12px;
    }
    #ai-panel textarea { min-height: 68px; resize: vertical; }
    #ai-panel .row { display: flex; gap: 8px; align-items: center; }
    #ai-panel .btn {
      background: #111827; color: #fff; border: 0; border-radius: 8px; padding: 8px 10px; font-size: 12px; cursor: pointer;
    }
    #ai-panel .btn.secondary { background: #f3f4f6; color: #111; border: 1px solid #e5e7eb; }
    #ai-panel .muted { color: #6b7280; font-size: 11px; }
    #ai-panel .output {
      background: #fafafa; border: 1px solid #eee; border-radius: 8px; min-height: 64px; padding: 8px; white-space: pre-wrap; font-size: 12px;
      max-height: 220px; overflow: auto;
    }

    @media (max-width: 600px) {
      #search-box-container { width: 80%; margin-left: -45%; top: 10px; }
      #toggle-directions {
        top: auto; bottom: 70px; left: 25%; transform: translateX(-50%);
        font-size: 16px; padding: 10px 16px;
      }
      #geolocate-button {
        top: auto; bottom: 20px; left: 50%; transform: translateX(-50%);
        font-size: 16px; padding: 10px 16px;
      }
      .mapboxgl-ctrl-top-left > .mapboxgl-ctrl-directions {
        margin-left: 20px !important; margin-top: 10px !important;
      }
      #stadium-address-filter { top: auto; bottom: 70px; right: 10%; z-index: 10; padding: 10px; }
      #ai-panel { top: auto; bottom: 110px; right: 10px; width: calc(100% - 20px); }
    }
  </style>
</head>
<body>
  <div id="search-box-container"></div>
  <button id="toggle-directions">Show Directions</button>
  <button id="geolocate-button">üìç Locate Me</button>

  <select id="stadium-address-filter">
    <option value="all">All Teams</option>
    <option value="USA">USA</option>
    <option value="Canada">Canada</option>
    <option value="Mexico">Mexico</option>
  </select>

  <!-- AI panel -->
  <div id="ai-panel">
    <header>
      <h3>AI Data Analyst</h3>
      <button id="ai-toggle" class="btn secondary" title="Hide">Hide</button>
    </header>
    <div class="content">
      <label>OpenAI API key (stored locally)
        <input id="ai-key" type="password" placeholder="sk-..." />
      </label>
      <div class="row" style="margin-top:8px">
        <label style="flex:1">CSV / Google Sheet (published CSV) URL
          <input id="ai-csv" type="text" placeholder="https://.../output=csv (optional)" />
        </label>
        <button id="ai-use-map" class="btn secondary" title="Use current map extent">Use map</button>
      </div>
      <label style="margin-top:6px">Question / Task
        <textarea id="ai-q" placeholder="e.g., List stadiums in Mexico with capacity > 60k and nearest airport."></textarea>
      </label>
      <div class="row" style="margin-top:8px">
        <button id="ai-run" class="btn">Analyze</button>
        <span id="ai-status" class="muted">idle</span>
      </div>
      <div id="ai-out" class="output" style="margin-top:8px"></div>
      <div class="muted" style="margin-top:6px">Tip: leave CSV empty to analyze features currently visible on the map.</div>
    </div>
  </div>

  <div id="map"></div>

  <script>
    const script = document.getElementById('search-js');
    script.onload = function () {
      const mapboxAccessToken = 'pk.eyJ1IjoiYWxlbmthZGljIiwiYSI6ImNtYW9iYzJtYTA1Ym8ya3NsbWNjanI0Ym4ifQ.e5NmEpb-fTD-6remlEm5rA';

      mapboxgl.accessToken = mapboxAccessToken;
      const map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/alenkadic/cmfrcxynq008g01s959qa0olo',
        center: [-103.213, 39.176],
        zoom: 3
      });

      map.addControl(new mapboxgl.NavigationControl());

      let directionsControl = null;
      let directionsVisible = false;

      document.getElementById('toggle-directions').addEventListener('click', function () {
        if (!directionsVisible) {
          directionsControl = new MapboxDirections({ accessToken: mapboxAccessToken });
          map.addControl(directionsControl, 'top-left');
          this.textContent = 'Hide Directions';
        } else {
          if (directionsControl) {
            map.removeControl(directionsControl);
            directionsControl = null;
          }
          this.textContent = 'Show Directions';
        }
        directionsVisible = !directionsVisible;
      });

      document.getElementById('geolocate-button').addEventListener('click', function () {
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(
            function (position) {
              const userLng = position.coords.longitude;
              const userLat = position.coords.latitude;

              map.flyTo({ center: [userLng, userLat], zoom: 13, essential: true });

              new mapboxgl.Marker({ color: '#007cbf' })
                .setLngLat([userLng, userLat])
                .setPopup(new mapboxgl.Popup().setText("You are here üìç"))
                .addTo(map);

              if (directionsControl) {
                directionsControl.setOrigin([userLng, userLat]);
              }
            },
            function () { alert('Geolocation failed or was denied.'); },
            { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
          );
        } else {
          alert("Your browser doesn't support geolocation.");
        }
      });

      // --- INTERACTION CODE (robust, with custom popups) ---
      map.on('style.load', () => {
        // Your intended layer names:
        const markerNames = [
          'Games',
          'Stadium Parking',   // polygon also listed here, harmless
          'Stadium Gates',
          'Stadiums',
          'Airports',
          'Team Hotels',
          'Team Training Facilities',
          'Cities'
        ];
        const polygonNames = ['Stadium Parking'];

        // Resolve friendly names to actual style layer IDs (handles tiny mismatches)
        const styleLayers = map.getStyle().layers.map(l => l.id);
        const resolveId = (name) => {
          if (styleLayers.includes(name)) return name;
          const hit = styleLayers.find(id => id.toLowerCase() === name.toLowerCase())
                    || styleLayers.find(id => id.toLowerCase().includes(name.toLowerCase()));
          return hit || name;
        };

        const markerLayers = markerNames.map(resolveId);
        const polygonLayers = polygonNames.map(resolveId);

        // Ensure layers are visible
        [...markerLayers, ...polygonLayers].forEach(id => {
          if (map.getLayer(id)) {
            const vis = map.getLayoutProperty(id, 'visibility');
            if (vis === 'none') map.setLayoutProperty(id, 'visibility', 'visible');
          }
        });

        // Stadium filter (by 'address' field); uses resolved layer ID
        const STADIUM_LAYER = resolveId('Stadiums');
        document.getElementById('stadium-address-filter').addEventListener('change', function (e) {
          const selectedKeyword = e.target.value;
          if (!map.getLayer(STADIUM_LAYER)) return;
          if (selectedKeyword === 'all') {
            map.setFilter(STADIUM_LAYER, null);
          } else {
            map.setFilter(STADIUM_LAYER, ['==', ['get', 'address'], selectedKeyword]);
          }
        });

        // ---------- Popup helpers & schema ----------
        function esc(s) { return String(s == null ? '' : s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
        function fmtMaybeLink(val) {
          const s = String(val || '');
          if (/^https?:\/\//i.test(s)) return `<a href="${esc(s)}" target="_blank" rel="noopener">${esc(s)}</a>`;
          return esc(s);
        }
        function gmapsLink(props, latKey='Latitude', lonKey='Longitude', addrKey='Address') {
          const lat = props[latKey], lon = props[lonKey];
          const addr = props[addrKey] ?? props[addrKey?.toLowerCase?.()] ?? props['address'];
          if (lat != null && lon != null && String(lat).trim() !== '' && String(lon).trim() !== '') {
            return `<a href="https://www.google.com/maps?q=${encodeURIComponent(lat+','+lon)}" target="_blank" rel="noopener">Open in Google Maps</a>`;
          }
          if (addr && String(addr).trim() !== '') {
            return `<a href="https://www.google.com/maps?q=${encodeURIComponent(addr)}" target="_blank" rel="noopener">Open in Google Maps</a>`;
          }
          return '';
        }

        const POPUP_CONFIG = {
          'Games': {
            fields: [
              ['Name', 'Stadium'],
              ['Round', 'Round'],
              ['Date', 'Date'],
              ['Time', 'Time'],
              ['Team 1', 'Team 1'],
              ['Team 2', 'Team 2'],
              ['Game link', 'Game link', true],
              ['Stadium', 'Stadium'],
              ['Address', 'Address'],
              ['City', 'City'],
              ['Latitude', 'Latitude'],
              ['Longitude', 'Longitude'],
              ['Capacity', 'Capacity'],
              ['Description', 'Description']
            ],
            gmaps: 'coords-or-address'
          },
          'Stadium Parking': {
            fields: [
              ['Name', 'Name'],
              ['Address', 'Address'],
              ['City', 'City'],
              ['Latitude', 'Latitude'],
              ['Longitude', 'Longitude'],
              ['(Optimal) Sector', '(Optimal) Sector'],
              ['(Optimal) Gate', '(Optimal) Gate'],
              ['Description', 'Description']
            ],
            gmaps: 'coords-or-address'
          },
          'Stadium Gates': {
            fields: [
              ['Name', 'Name'],
              ['Address', 'Address'],
              ['City', 'City'],
              ['Latitude', 'Latitude'],
              ['Longitude', 'Longitude'],
              ['(Optimal) Sector', '(Optimal) Sector'],
              ['(Optimal) Parking', '(Optimal) Parking'],
              ['Description', 'Description']
            ],
            gmaps: 'coords-or-address'
          },
          'Stadiums': {
            fields: [
              ['Name', 'Name'],
              ['Address', 'Address'],
              ['City', 'City'],
              ['Latitude', 'Latitude'],
              ['Longitude', 'Longitude'],
              ['Capacity', 'Capacity'],
              ['Stadium Map', 'Stadium Map', true],
              ['Description', 'Description']
            ],
            gmaps: 'coords-or-address'
          },
          'Airports': {
            fields: [
              ['Name', 'Name'],
              ['Airport_Ident', 'Airport Code'],
              ['Airport_Type', 'Airport size'],
              ['Latitude', 'Latitude'],
              ['Longitude', 'Longitude'],
              ['City_1', 'Nearby City 1'],
              ['Distance_Miles_1', 'Miles to Nearby City 1'],
              ['City_2', 'Nearby City 2'],
              ['Distance_Miles_2', 'Miles to Nearby City 2'],
              ['City_3', 'Nearby City 3'],
              ['Distance_Miles_3', 'Miles to Nearby City 3'],
              ['City_4', 'Nearby City 4'],
              ['Distance_Miles_4', 'Miles to Nearby City 4']
            ],
            gmaps: 'coords-or-address'
          },
          'Team Hotels': {
            fields: [
              ['Name', 'Name'],
              ['Address', 'Address'],
              ['City', 'City'],
              ['Latitude', 'Latitude'],
              ['Longitude', 'Longitude'],
              ['Team', 'Team'],
              ['Paired Training Facility', 'Paired Training Facility']
            ],
            gmaps: 'coords-or-address'
          },
          'Team Training Facilities': {
            fields: [
              ['Name', 'Name'],
              ['Address', 'Address'],
              ['City', 'City'],
              ['Latitude', 'Latitude'],
              ['Longitude', 'Longitude'],
              ['Team', 'Team'],
              ['Paired Hotel', 'Paired Hotel']
            ],
            gmaps: 'coords-or-address'
          },
          'Cities': {
            fields: [
              ['Name', 'Name'],
              ['Latitude', 'Latitude'],
              ['Longitude', 'Longitude'],
              ['Category', 'Category'],
              ['Description', 'Description'],
              ['URL', 'Website', true]
            ],
            gmaps: 'coords-or-address'
          }
        };

        function renderPopupHTML(layerId, props) {
          const cfg = POPUP_CONFIG[layerId] || { fields: [], gmaps: 'coords-or-address' };
          const parts = [];
          for (const [key, label, makeLink] of cfg.fields) {
            if (!(key in props)) continue;
            const val = props[key];
            if (val == null || String(val).trim() === '') continue;
            const valueHtml = makeLink ? fmtMaybeLink(val) : esc(val);
            parts.push(`<div><b>${esc(label)}:</b> ${valueHtml}</div>`);
          }
          if (cfg.gmaps !== 'none') {
            const gm = gmapsLink(props);
            if (gm) parts.push(`<div style="margin-top:6px">${gm}</div>`);
          }
          return parts.join('') || '(no data)';
        }

        function bindLayerHandlers(layerId, isPolygon) {
          if (!map.getLayer(layerId)) return;
          map.on('click', layerId, (e) => {
            const feat = e.features && e.features[0];
            const props = (feat && feat.properties) || {};
            const html = renderPopupHTML(layerId, props);
            new mapboxgl.Popup().setLngLat(e.lngLat).setHTML(html).addTo(map);
          });
          map.on('mouseenter', layerId, () => { map.getCanvas().style.cursor = 'pointer'; });
          map.on('mouseleave', layerId, () => { map.getCanvas().style.cursor = ''; });
        }

        markerLayers.forEach(id => bindLayerHandlers(id, false));
        polygonLayers.forEach(id => bindLayerHandlers(id, true));
      });
      // --- END INTERACTION CODE ---

      // Geocoder (Search)
      const geocoder = new mapboxsearch.MapboxGeocoder();
      geocoder.accessToken = mapboxAccessToken;
      geocoder.options = { proximity: [-103.213, 39.176] };
      geocoder.mapboxgl = mapboxgl;
      geocoder.marker = true;
      geocoder.bindMap(map);
      document.getElementById('search-box-container').appendChild(geocoder);

      // -------------- AI PANEL LOGIC --------------
      const els = {
        panel: document.getElementById('ai-panel'),
        toggle: document.getElementById('ai-toggle'),
        key: document.getElementById('ai-key'),
        csv: document.getElementById('ai-csv'),
        q: document.getElementById('ai-q'),
        run: document.getElementById('ai-run'),
        useMap: document.getElementById('ai-use-map'),
        status: document.getElementById('ai-status'),
        out: document.getElementById('ai-out')
      };

      // load/save key
      els.key.value = localStorage.getItem('OPENAI_API_KEY') || '';
      els.key.addEventListener('change', ()=> localStorage.setItem('OPENAI_API_KEY', els.key.value));

      els.toggle.addEventListener('click', () => {
        const showing = els.panel.classList.toggle('collapsed');
        if (showing) {
          els.panel.querySelector('.content').style.display = 'none';
          els.toggle.textContent = 'Show';
        } else {
          els.panel.querySelector('.content').style.display = '';
          els.toggle.textContent = 'Hide';
        }
      });

      // Gather visible features (by layer) as lightweight rows
      function collectVisibleFeatures() {
        const bounds = map.getBounds();
        const layers = map.getStyle().layers
          .filter(l => ['symbol','circle','fill','line'].includes(l.type))
          .map(l => l.id);
        const feats = map.queryRenderedFeatures({ layers, filter: ['has', 'layer'], bbox: [bounds.getWest(), bounds.getSouth(), bounds.getEast(), bounds.getNorth()] });
        // Compact dataset: {layerId: [{...props} ...]}
        const byLayer = {};
        for (const f of feats) {
          const id = f.layer.id;
          (byLayer[id] ||= []).push(f.properties);
        }
        // Limit rows per layer to keep prompt light
        for (const k in byLayer) byLayer[k] = byLayer[k].slice(0, 250);
        return byLayer;
      }

      // Load CSV if provided
      async function loadCsv(url) {
        return new Promise((resolve, reject) => {
          Papa.parse(url, {
            header:true, download:true, dynamicTyping:true,
            complete: (res) => resolve(res.data.filter(r => Object.keys(r).some(k => String(r[k]||'').trim() !== ''))),
            error: reject
          });
        });
      }

      async function callOpenAI(apiKey, system, user) {
        const resp = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: { 'Content-Type':'application/json', 'Authorization':'Bearer ' + apiKey },
          body: JSON.stringify({
            model: 'gpt-4o-mini', // light & good for analysis/summaries
            temperature: 0.2,
            messages: [
              { role:'system', content: system },
              { role:'user', content: user }
            ]
          })
        });
        if (!resp.ok) throw new Error('OpenAI error ' + resp.status);
        const data = await resp.json();
        return data.choices?.[0]?.message?.content?.trim() || '(no response)';
      }

      let cachedMapSample = null;
      els.useMap.addEventListener('click', () => {
        cachedMapSample = collectVisibleFeatures();
        els.csv.value = ''; // make it clear we're using the map view
        els.status.textContent = 'captured current map view';
      });

      els.run.addEventListener('click', async () => {
        try {
          els.status.textContent = 'preparing‚Ä¶';
          els.out.textContent = '';

          const apiKey = els.key.value.trim();
          if (!apiKey) { alert('Please paste your OpenAI API key.'); return; }

          let dataset = null;
          if (els.csv.value.trim()) {
            els.status.textContent = 'loading CSV‚Ä¶';
            dataset = await loadCsv(els.csv.value.trim());
          } else {
            els.status.textContent = 'sampling map‚Ä¶';
            dataset = cachedMapSample || collectVisibleFeatures();
          }

          const question = els.q.value.trim() || 'Give me a concise overview of the dataset.';
          const system = `You analyze geospatial tables. Be precise and concise. If coordinates are present, treat them as WGS84. If fields look like URLs, present them as links in your answer. If asked for recommendations (e.g., nearest airports), reason step-by-step but only output the final answer.`;
          const user = `QUESTION:\n${question}\n\nDATA SAMPLE (stringified JSON):\n${JSON.stringify(dataset).slice(0, 120000)}\n\nNotes:\n- If dataset is an object, keys are map layer IDs with arrays of feature properties.\n- If it's an array, each item is a row from the CSV.`;

          els.status.textContent = 'calling model‚Ä¶';
          const answer = await callOpenAI(apiKey, system, user);
          els.out.innerHTML = answer
            .replace(/</g,'&lt;')
            .replace(/\[(https?:\/\/[^\]\s]+)\]/g, '<a href="$1" target="_blank">$1</a>');
          els.status.textContent = 'done';
        } catch (e) {
          console.error(e);
          els.status.textContent = 'error';
          els.out.textContent = 'Error: ' + e.message;
        }
      });
      // -------------- END AI PANEL LOGIC --------------
    };
  </script>
</body>
</html>







